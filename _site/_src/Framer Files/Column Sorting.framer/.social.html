<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		
		<meta name="format-detection" content="telephone=no">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<script type="text/javascript">
		// This automatically sets the right viewport scale on mobile devices
		(function() {
 		var scale = 1 / window.devicePixelRatio
 		var viewport = "width=device-width, height=device-height, initial-scale=" + scale + ", maximum-scale=" + scale + ", user-scalable=no"
 		var iOS = /iPad|iPhone|iPod/.test(navigator.platform)
 		if (iOS) { viewport += ", shrink-to-fit=no" }
 		document.write("<meta name=\"viewport\" content=\"" + viewport + "\">")
		})()
		</script>

		<link rel="apple-touch-icon" href="framer/images/icon-120.png">
		<link rel="apple-touch-icon" href="framer/images/icon-76.png" sizes="76x76">
		<link rel="apple-touch-icon" href="framer/images/icon-120.png" sizes="120x120">
		<link rel="apple-touch-icon" href="framer/images/icon-152.png" sizes="152x152">
		<link rel="apple-touch-icon" href="framer/images/icon-180.png" sizes="180x180">
		<link rel="apple-touch-icon" href="framer/images/icon-192.png" sizes="192x192">

		<link rel="stylesheet" type="text/css" href="framer/style.css?nocache=6d40bc53861208d298f85019e08849ff">

		<script src="framer/coffee-script.js"></script>
		<script src="framer/framer.js?nocache=de1b3b046cd7a44d11f275a7634f9e0b"></script>
		<script src="framer/framer.generated.js?nocache=8dcd16e27cf2eedd159ad63ef4d907e7"></script>
		<script src="framer/framer.modules.js?nocache=96cc1080fba4eb8e68f7c0fabd317b53"></script>
		<script>document.addEventListener("DOMContentLoaded", function() {window.__framerClientCodeId = 9;window.__framerNew = function (n,loc,th,i){if (i == null) { return i };i.__framerInstanceInfo = _.defaults({name:n,location:loc,hash:th},i.__framerInstanceInfo);_.defaults(i.__framerInstanceInfo,{name:"Untitled"});return i;};(function() {
  var arr, bg, bgColor, changeCol, closestIndex, colGutter, colWidth, columnArrays, columnContent, container, currentCol, heightVal, i, j, jrdSpring, k, laneWidth, len, list, midXs, pd, randoCol, ref, sizeSwimLane, sortVertically, startCol, startIndex, swimlane, swimlanes, tile, tileContent, tileHeight, updateIndex;

  jrdSpring = "spring(500, 50, 10)";

  Framer.Defaults.Animation = {
    curve: jrdSpring
  };

  columnContent = ["A", "B", "C", "D"];

  tileContent = 10;

  colWidth = 100;

  tileHeight = 64;

  colGutter = 48;

  pd = 8;

  laneWidth = colWidth + (pd * 2);

  bgColor = window.__framerNew(undefined, "16:14-16:29", "@Color",new Color("#00AAFF")).lighten(20);

  columnArrays = [];

  swimlanes = [];

  startCol = null;

  startIndex = null;

  currentCol = null;

  closestIndex = function(number, array) {
    var a, current, each, j, len;
    current = 0;
    for (a = j = 0, len = array.length; j < len; a = ++j) {
      each = array[a];
      if (Math.abs(number - each) < Math.abs(number - array[current])) {
        current = a;
      }
    }
    return current;
  };

  updateIndex = function(layer, array) {
    var midYs;
    midYs = array.map(function(i) {
      return i.midY;
    });
    if (midYs[startIndex] <= midYs[startIndex - 1]) {
      array.splice(startIndex, 1);
      array.splice(startIndex - 1, 0, layer);
      startIndex = array.indexOf(layer);
      return sortVertically(array);
    } else if (midYs[startIndex] >= midYs[startIndex + 1]) {
      array.splice(startIndex, 1);
      array.splice(startIndex + 1, 0, layer);
      startIndex = array.indexOf(layer);
      return sortVertically(array);
    }
  };

  sizeSwimLane = function(index) {
    var heightVal;
    swimlanes[index].animateStop();
    heightVal = pd + ((tileHeight + pd) * columnArrays[index].length);
    if (heightVal < 200) {
      heightVal = 200;
    }
    return swimlanes[index].animate({
      properties: {
        height: heightVal
      }
    });
  };

  sortVertically = function(array) {
    var j, len, results, t, tile;
    results = [];
    for (t = j = 0, len = array.length; j < len; t = ++j) {
      tile = array[t];
      tile.animateStop();
      if (tile.draggable.isDragging === false) {
        results.push(tile.animate({
          properties: {
            y: 8 + (tileHeight + pd) * t
          }
        }));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  changeCol = function(layer, yVal) {
    columnArrays[startCol].splice(startIndex, 1);
    columnArrays[currentCol].splice(yVal, 0, layer);
    return startCol = currentCol;
  };

  bg = window.__framerNew("bg", "91:9-91:48", "#fae35565",new BackgroundLayer({
    backgroundColor: bgColor
  }));

  container = window.__framerNew("container", "93:16-101:47", "#153728f89",new Layer({
    width: (laneWidth * columnContent.length) + (colGutter * (columnContent.length - 1)),
    x: Align.center,
    y: Align.center,
    height: bg.height - 48,
    backgroundColor: ""
  }));

  for (i = j = 0, len = columnContent.length; j < len; i = ++j) {
    list = columnContent[i];
    swimlane = window.__framerNew("swimlane", "104:16-113:0", "#120c86398",new Layer({
      width: laneWidth,
      borderRadius: 6,
      height: 200,
      parent: container,
      x: (laneWidth * i) + (colGutter * i),
      backgroundColor: bgColor.darken(7)
    }));
    swimlanes.push(swimlane);
    arr = [];
    columnArrays.push(arr);
  }

  midXs = swimlanes.map(function(i) {
    return i.midX;
  });

  for (tile = k = 0, ref = tileContent; 0 <= ref ? k <= ref : k >= ref; tile = 0 <= ref ? ++k : --k) {
    randoCol = Utils.round(Utils.randomNumber(0, swimlanes.length - 1), 0);
    tile = window.__framerNew("tile", "130:12-143:0", "#13dd89f1b",new Layer({
      width: colWidth,
      height: tileHeight,
      borderRadius: 4,
      color: "#999",
      backgroundColor: "white",
      parent: container,
      x: swimlanes[randoCol].x + pd,
      shadowY: 1,
      shadowBlur: 2,
      shadowColor: "rgba(0,0,0,.1)"
    }));
    columnArrays[randoCol].push(tile);
    tile.y = 8 + (tileHeight + pd) * (columnArrays[randoCol].length - 1);
    tile.draggable.enabled = true;
    heightVal = columnArrays[randoCol][columnArrays[randoCol].length - 1].maxY + pd;
    if (heightVal < 200) {
      heightVal = 200;
    }
    swimlanes[randoCol].height = heightVal;
    tile.on(Events.TouchStart, function(event, layer) {
      startCol = closestIndex(this.midX, midXs);
      currentCol = startCol;
      startIndex = columnArrays[startCol].indexOf(this);
      this.bringToFront();
      return this.animate({
        properties: {
          scale: 1.1,
          shadowY: 4,
          shadowBlur: 8,
          shadowColor: "rgba(0,0,0,.2)"
        }
      });
    });
    tile.on(Events.DragMove, function(event, layer) {
      updateIndex(this, columnArrays[startCol]);
      currentCol = closestIndex(layer.midX, midXs);
      if (currentCol !== startCol) {
        columnArrays[startCol].splice(startIndex, 1);
        columnArrays[currentCol].splice(startIndex, 0, layer);
        sortVertically(columnArrays[currentCol]);
        sortVertically(columnArrays[startCol]);
        sizeSwimLane(startCol);
        sizeSwimLane(currentCol);
        return startCol = currentCol;
      }
    });
    tile.on(Events.DragEnd, function(event, layer) {
      return this.animate({
        properties: {
          y: 8 + (tileHeight + pd) * (columnArrays[currentCol].indexOf(this)),
          x: swimlanes[currentCol].x + pd,
          scale: 1,
          shadowY: 1,
          shadowBlur: 1,
          shadowColor: "rgba(0,0,0,.1)"
        }
      });
    });
    tile.on(Events.TouchEnd, function(event, layer) {
      return this.animate({
        properties: {
          y: 8 + (tileHeight + pd) * (columnArrays[currentCol].indexOf(this)),
          x: swimlanes[currentCol].x + pd,
          scale: 1,
          shadowY: 1,
          shadowBlur: 1,
          shadowColor: "rgba(0,0,0,.1)"
        }
      });
    });
  }

}).call(this);
})</script>

	</head>
	<body>
	</body>
</html>